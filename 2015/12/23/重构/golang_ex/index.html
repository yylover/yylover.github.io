<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="package main
func main() {
}//1. 值 引用//go语言的特性//
/*第二章 变量**//* 变量是一块存储区域的命名
///变量声明func var_declare() {    //    var v1 int    //    var v2 string //    var v0 [10]int    var v3 []int  //数组切片    var v">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/2015/12/23/重构/golang_ex/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="package main
func main() {
}//1. 值 引用//go语言的特性//
/*第二章 变量**//* 变量是一块存储区域的命名
///变量声明func var_declare() {    //    var v1 int    //    var v2 string //    var v0 [10]int    var v3 []int  //数组切片    var v">
<meta property="og:updated_time" content="2016-07-09T10:08:27.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
<meta name="twitter:description" content="package main
func main() {
}//1. 值 引用//go语言的特性//
/*第二章 变量**//* 变量是一块存储区域的命名
///变量声明func var_declare() {    //    var v1 int    //    var v2 string //    var v0 [10]int    var v3 []int  //数组切片    var v">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Buscar"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-重构/golang_ex" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/12/23/重构/golang_ex/" class="article-date">
  <time datetime="2015-12-23T12:36:49.000Z" itemprop="datePublished">2015-12-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>package main</p>
<p>func main() {</p>
<p>}<br>//1. 值 引用<br>//go语言的特性<br>//</p>
<p>/<strong><strong><strong><strong><em>*</em></strong></strong></strong></strong>第二章 变量<strong><strong><strong><strong>**</strong></strong></strong></strong>/<br>/* 变量是一块存储区域的命名</p>
<p><em>/<br>//变量声明<br>func var_declare() {<br>    //<br>    var v1 int    //<br>    var v2 string //<br>    var v0 [10]int<br>    var v3 []int  //数组切片<br>    var v5 struct {<br>        f int<br>    }<br>    var v6 </em>int            //指针<br>    var v7 map[string]int  //map<br>    var v8 func(a int) int //函数</p>
<pre><code>//可以同时声明多个变量
var (
    vv1 int
    vv2 string
)
</code></pre><p>}</p>
<p>//变量初始化<br>func var_initail() {<br>    var v1 int = 10<br>    var v2 = 10 //编译器可以推导v2类型<br>    v3 := 10    // 编译器可以推导v3类型</p>
<pre><code>//这里让Go语言看起来像动态语言，实际上，Go是强类型语言（静态语言）。

//变量的赋值，赋值与初始化是不同的概念
var i = 10
var j = 20
//变量的多重赋值
i, j = j, i


//匿名变量
_, _ , nickname := GetName()//func GetName()(firstname, lastname, nickname)
</code></pre><p>}</p>
<p>// constant 常量：编译期间就已知且不可改变的值<br>func constant() {<br>    //字面型常量<br>    -13<br>    true<br>    “foo”</p>
<pre><code>//常量定义，采用const
const PI float64 = 3.1415926
const (
    size int64 = 1024
    eof = -1
    mask = 1 &lt;&lt; 3//也可以是编译期间运算的常量表达式
)

//预定义常量
true false itoa//itoa可以被编译器修改的常量，每一个const关键字出现时置为0
const (
    a = 1 &lt;&lt; itoa //1
    b = 1 &lt;&lt; itoa //2
    c = 1 &lt;&lt; itoa //4
)

//枚举 Go并不支持常规语言的enum关键字
const (
    Sunday = iota
    Monday
    ...
)
</code></pre><p>}</p>
<p>//types 变量类型<br>func var_types() {<br>    //1. bool<br>    //2. 整型 int8 uint8 byte int16 uint16 int uint int32 uint32 int64 uint64 uintptr<br>    //3. 浮点 float32 float64<br>    //4. 复数 complex64 complex128<br>    //5. 字符串 string<br>    //6. 字符类型： rune<br>    //7. 错误类型： error</p>
<pre><code>//符合类型
//1. 指针
//2. 数组
//3. 切片
//4. map
//5. chan
//6. struct
//7. interface

//1 bool
var b1 bool
b1 = false
b1 = (1 == 2)
b1 = bool(1) //错误,bool不接受其他类型值，不支持自动或强制转换

//int int32在Go语言是两种不同的类型，编译器不会做自动类型转换，需要自己进行转换
value2 = int32(value3)
//运算： + - * / %
//比较： &gt; &lt; &gt;= &lt;= == !=
//位运算: x &lt;&lt; y x &gt;&gt; y x^y x&amp;y  x|y ^x

//float32 float64相当于c语言的float double类型
var f1 float64 = 1.0001
var f2 float64 = 1.0002
//比较
isEqual := math.Dim(f1, f2) &lt; 0.0001

//复数
value1 := 3.2 + 12i
rel := real(value1) //实部
img := imag(z) //虚部

//字符串不可改变
var s1 string = &quot;test&quot;
s1 = s1 + &quot;abcd&quot; // 字符串拼接
c1 = s1[2]  //取字符，
lenth := len(s1) //长度
s1 = `\w+`  //反引号，不转义，常用于正则表达式

//字符遍历 字节数组方式
for i := 0; i &lt; n; i++ {
    ch := str[i]
}

//Unicode字符rune,每个字符是rune,代表单个Unicode字符
str := &quot;hello, 语言&quot;
for i, ch := range str {

}

//数组:不可变类型
var arr1 [32]int //字节数组
var arr2 [10]*float64 //指针数组
var arr3 [3][5]int //二维数组
var arr4 [2][2][4]float64 //三维数组

//初始化
arr1 = [32]int{1,2,3,4}
//临时结构体数组
structArray := []struct{
    name string
    age int
}{{"time", 18}, {"yang", 24}}

//数组遍历
for i := 0; i &lt; len(arr1); i++ {
    fmt.Println(arr1[i])
}
for i, v := range arr1 {
    fmt.Println(v)
}

//切片
//切片的数据结构可以抽象为：指向原数组的指针；数组切片中元素的个数；数组切片已经分配的存储空间
//创建方式：1 处于数组arrayname[first, last] 2 直接创建
var myArray [10]int = [10]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
var mySlice []int = myArray[:5]
//myslice = myArr[:] 所有元素
//myslice = myArr[:5] 前5个元素
mySlice1 := make([]int, 5)
mySlice2 := make([]int, 5, 10) //初始长度5，预留10个存储空间，即：len=5,cap=10
mySlice3 := []int{1, 2, 3, 4, 5}

//遍历方式与数组相同，有两种方式
fmt.Println(&quot;len(mySlice):&quot;, len(mySlice)) //len 是当前存储元素个数
fmt.Println(&quot;cap(mySlice):&quot;, cap(mySlice)) //cap 数组切片分配的空间大小

//动态增加元素
mySlice4 := append(mySlice3, 6, 7, 8)    //append ,append开始位置不会占用之前的,不会改变之前的切片
mySlice5 := append(mySlice3, mySlice2...) //将一个数组切片追加到另一个切片末尾

//基于数组切片创建切片
mySlice6 := mySlice5[:5]

//copy 如果前后两个切片个数不同，那么安装较小的切片进行复制 ， 假设mySlice1 3个元素，mySlice2 5个元素
copy(mySlice1, mySlice2) //只复制前三个,会改变slice1
copy(mySlice2, mySlice1) //只复制三个

//Map
var myMap map[string] PersonalInfo //声明
myMap = make(map[string] PersonalInfo)  //创建
myMap = make(map[string] PersonalInfo, 10) //指定存储能力
myMap[&quot;123&quot;] = PersonalInfo{&quot;1&quot;, &quot;Jack&quot;, &quot;Room&quot;} //赋值
delete(myMap, &quot;123&quot;)  //元素删除
value, ok := myMap[&quot;123&quot;] //元素的查找
if ok {
    //找到
}

//遍历
for key, val := range myMap {

}
</code></pre><p>}</p>
<p>//流程控制<br>func flow_control() {<br>    //1. 条件 if else  else if<br>    //2. 选择 switch case select<br>    //3. 循环 for range<br>    //4. 跳转 goto</p>
<pre><code>if a = 5; a &lt; 5 {
    return false
} else {
    return true
}

// switch
switch i {
case 0:
    fmt.Println(0)
case 1:
    fallthrough //添加后才会紧接执行下一个case
case 3:
    fmt.Println(3)
default:
    fmt.Println(&quot;Default&quot;)
}

//如果省略switch后的表达式，与if ...else...逻辑相同
switch {
case 0 &lt;= num &amp;&amp; num &lt;= 3:
    fmt.Println(&quot;0-3&quot;)
case 4 &lt;= num &amp;&amp; num &lt;=6:
    fmt.Println(&quot;4-6&quot;)
}

//循环只支持for
for i := 0; i &lt; 10; i++ {

}
//无限循环
for {
    sum ++
    if sum &gt; 100 {
        break
    }
}
//条件表达式支持多重赋值， break可以选择中断哪一个循环
for i, j : =0, len(a) -1 ; i &lt; j; i, j = i+1, j-1 {
    for k := 0; k &lt; j; k++ {
        break JLoop
    }
}
JLoop:

//跳转
HERE:
i++
if i &lt; 10 {
    goto HERE
}
</code></pre><p>}</p>
<p>//函数 functions<br>//func func_name(参数列表)(返回值列表)<br>func Add(a, b int) (ret int, err error) {//参数列表多个相邻的参数类型相同，可以省略前面的类型声明<br>    if a &lt; 0 || b &lt; 0 {<br>        err = errors.New(“Should be non-negative numbers”)<br>        return //可以直接对返回值设置<br>    }<br>    return a + b, nil<br>}</p>
<p>//访问控制：对于函数，类型和变量，小写字母开头只在本包内可见，大写字母开头的才在包外使用；</p>
<p>//不定参数<br>//myFunc(1, 2, 3) 调用方式<br>func myFunc(args …int) {<br>    for _, arg := range args {</p>
<pre><code>}

//传递
myfunc3(args...)
myfunc3(args[1:]...)
</code></pre><p>}</p>
<p>//任意类型不定参数<br>//args.(type) 在switch 中类型判断，interface{}具体的一种类型判断host, ok := host.(string)<br>func MyPrintf(args …interface{}) {<br>    for _, arg := range args {<br>        switch arg.(type) {<br>        case int:<br>            fmt.Println(arg, “ is an int value”)<br>        case string:<br>            fmt.Println(arg, “ is an string value”)<br>        default:<br>            fmt.Println(arg, “ is Unknown value”)<br>        }<br>    }<br>}</p>
<p>//匿名函数与闭包<br>/*<br>闭包：可以包含自由（未绑定到特定对象）变量的代码块，这些变量不再这个代码块中或者任何全局上下文中定义，而是在定义代码块的环境中定义。<br>意义：闭包可以作为函数对象或者匿名函数， 函数可以作为第一级对象，存储到变量中作为参数传递。能被函数动态创建和返回<br>匿名函数:不需要定义函数名的一种函数实现方式。函数可以赋值被变量或直接执行(花括号后面跟参数列表表示函数调用)</p>
<p><em>/<br>//有疑问?????<br>func main() {<br>    var j int = 5<br>    a := func()(func()) {<br>        var i int = 10<br>        return func() {<br>            fmt.Printf(“i, j: %d, %d\n”, i, j)<br>        }<br>    }()<br>    a() // 10 5<br>    j </em>= 2<br>    a() // 10 10<br>}</p>
<p>//错误处理， 漂亮的错误处理是Go语言的最大亮点之一<br>//错误处理流程: 当在一个函数执行过程中调用panic()函数时,正常的函数执行流程将立终止,但函数中之前使用defer关键字将开始执行，<br>//之后该函数将返回到调用函数,并导致逐层向上执行panic流程,直到所属的goroutine中所有正在执行的函数被终 。<br>func CopyFileDemo() {<br>    srcFile, err := os.Open(src)<br>    if err != nil {<br>        return<br>    }<br>    defer srcFile.Close()</p>
<pre><code>//匿名函数
defer func() {
    //负责的清理工作
    if r := recover(); r := nil {
        fmt.Printf(&quot;runtime error caught :%v&quot;, r)
    }
    }()

//func panic(interface{}) 报告运行时错误
//func recover() interface{} 处理运行时错误或程序错误,用于中止错误处理流程
</code></pre><p>}</p>
<p>/<strong><strong><strong><strong><em>*</em></strong></strong></strong></strong>第三章 面向对象编程<strong><strong><strong><strong>**</strong></strong></strong></strong>/<br>/*<br>类型系统是一门编程语言的基础，典型的类型系统包括以下内容：</p>
<ol>
<li>基础类型byte int bool float</li>
<li>复合类型:数组、结构体、指针等</li>
<li>可以指向任意对象的类型Any</li>
<li>值语义和引用语义</li>
<li>面向对象</li>
<li>接口<br>*/</li>
</ol>
<p>//可以为任意类型添加方法<br>type Integer int<br>func (a Integer) Less(b Integer) bool {<br>    return a &lt; b<br>}</p>
<p>//修改原对象的时候，需要使用指针<br>func (a *Integer) Add(b Integer) {<br>    a += b<br>}</p>
<p>/*<br>值引用： Go中大多数都是值语义<br>值语义和引用语义的区别在于赋值。值语义不会影响a的值。</p>
<ol>
<li>基本类型， byte, int, bool, float32, float64, string</li>
<li>复合类型： array struct 指针<br>下面四个类型比较特殊，看起来像引用类型<br>切片 map channel interface, 其实现内部维护一个指针，本身还是值语义<br>接口:<br>type interface struct{<br> data <em>void<br> itab </em>Itab<br>}<br>*/</li>
</ol>
<p>//结构体： Go语言中的结构体跟其他语言中的类有相同的地位，其放弃了继承在内的大量面向对象特性，只保留组合<br>type Rect struct {<br>    x, y float<br>    width, height float64<br>}</p>
<p>//初始化<br>rect1 := new(Rect)<br>rect2 := &amp;Rect{}<br>rect3 := &amp;Rect{0, 0, 100, 200}<br>rect4 := &amp;Rect{width:100, height: 200} //未显示初始化的被初始化为该类型零值</p>
<p>//匿名组合<br>type Base struct {<br>    Name string<br>}</p>
<p>func (base <em>Base) Foo() {}<br>func (base </em>Base) Bar() {}</p>
<p>type Foo struct {<br>    Base<br>}<br>func (foo <em>Foo) Bar() {<br>    foo.Base.Bar()<br>}<br>//指针方式派生<br>type Job struct {<br>    Command string
    </em>log.Logger<br>}</p>
<p>//可见性:包级别，首字母大小写控制</p>
<p>//接口：非侵入性，一个类只需实现所有函数，就说这个类实现了该接口</p>
<p>//接口赋值：对象赋值给接口;接口赋值接口(接口赋值不要求必须等价，如果接口A方法列表是接口B方法列表自己，接口B可以赋值给A)<br>var a Integer = 1<br>var b LessAddr = &amp;a</p>
<p>//接口查询 判断一个对象实例是否实现了某接口，必须运行期才能确定<br>var file1 Writer = …<br>if file5, ok := file1.(two.IStream); ok {<br>    …<br>}</p>
<p>//判断类型<br>if file3, ok := file.(*File); ok {<br>    …<br>}</p>
<p>//查询类型<br>switch v := file.(type) {<br>case int :<br>case string:<br>}</p>
<p>//接口组合<br>type ReadWriter interface {<br>    Reader<br>    Writer<br>}</p>
<p>//Any 类型 interface{}</p>
<p>/<strong><strong><strong><strong><em>*</em></strong></strong></strong></strong>第四章 并发编程<strong><strong><strong><strong>**</strong></strong></strong></strong>/<br>/* 优雅的并发编程范式，完善的并发支持，出色的并发性能是Go区别于其他语言的特色。<br>channel是Go语言级别提供的goroutine间的通信方式。可以使用channel在两个或多个goroutine之间传递消息</p>
<p>*/<br>func channel_goroutine() {<br>    //声明<br>    var chanName chan ElementType<br>    //定义<br>    ch := make(chan int)<br>    ch &lt;- value //数据写入<br>    value := &lt;-ch  //读数据</p>
<pre><code>//select 语法类型switch，每个case必须是IO操作

//缓冲区
c := make(chan int, 1024)

//读写超时机制应对channel错误处理

// channel的传递

var ch2 chan&lt;- int //单向写channel
 var ch3 &lt;-chan int //单向读channel
 close(ch3) //关闭channel
 if x, ok := &lt;-ch3; !ok {
     //ch3已经关闭
 }

 runtime.Gosched() //出让时间片

 runtime.GOMAXPROCS(runtime.NumCPU()) //多核并行

 var l1 sync.Mutex
 var l2 sync.RWMutex

 var once sync.Once //全局唯一性操作
 once.Do(setup) //setup函数只会被执行一次
</code></pre><p>}</p>
<p>/<em>*</em><br>工程管理<br>自带gotool功能:go version; go help;<br>GOPATH,通过此变量找到相应的包名</p>
<p>测试</p>
<p>*/</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/12/23/重构/golang_ex/" data-id="ciqgvgdqs0000x738fy9l7n5h" class="article-share-link">Compartir</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/02/29/重构/go_doc1/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Nuevo</strong>
      <div class="article-nav-title">
        
          (no title)
        
      </div>
    </a>
  
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archivos</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">February 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">December 2015</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Posts recientes</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/07/11/重构/重构基础/">重构基础</a>
          </li>
        
          <li>
            <a href="/2016/07/11/go/Go语言特性/">Go语言特性</a>
          </li>
        
          <li>
            <a href="/2016/07/11/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2016/02/29/重构/go_doc1/">(no title)</a>
          </li>
        
          <li>
            <a href="/2015/12/23/重构/golang_ex/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 John Doe<br>
      Construido por <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>




  </div>
</body>
</html>